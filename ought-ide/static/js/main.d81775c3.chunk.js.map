{"version":3,"sources":["parser/regexes.ts","parser/char.ts","parser/token.ts","parser/parser.ts","parser/keywords.ts","actions/loadProgramFromString.ts","actions/saveValue.ts","actions/runStatement.ts","actions/runNextStep.ts","components/Value.tsx","actions/loadProgram.ts","actions/submitInput.ts","actions/finishProcessingInput.ts","components/App.tsx","actions/toggleAutoRun.ts","reducers/printedLines.ts","reducers/session.ts","reducers/steps.ts","reducers/variables.ts","reducers/index.ts","index.tsx","serviceWorker.ts"],"names":["IS_COLON_REGEX","IS_IDENTIFIER_REGEX","IS_NEWLINE_REGEX","IS_SEMICOLON_REGEX","IS_STRING_LITERAL_REGEX","IS_STRING_LITERAL_DELIMITER_REGEX","IS_WHITESPACE_REGEX","Char","char","Object","classCallCheck","this","createClass","key","value","isWhitespace","isNewline","isSemicolon","isColon","match","Token","tokenString","keyword","Parser","code","curLoc","isAtEndOfProgram","parseProgram","statement","startLoc","statements","parseStatement","nested","push","type","loc","start","end","_ref","skipWhitespace","nextToken","peekAtNextToken","isKeyword","parseAddStatement","parseIfEqualStatement","parseIfNotEqualStatement","parseInputStatement","parsePrintStatement","parseRunStatement","parseSetStatement","parseStopStatement","curChar","parseSemicolonStatement","eatEndOfStatement","endLoc","objectSpread","Error","eatToken","first","parseExpression","second","sum","parseIdentifier","firstAntecedentValue","secondAntecedentValue","eatChar","consequent","identifier","expression","program","firstStatement","secondStatement","isThereANextChar","wasEndOfStatementEncountered","isEndOfStatement","goToNextChar","isStringLiteral","getStringValue","isIdentifier","expectedChar","getValue","concat","isStringDelimiter","eatStringLiteral","isTokenDelimiter","stringLiteral","length","loadProgramFromString","dispatch","getState","parser","generateAST","e","console","log","errorMsg","message","saveValue","evaluateExpression","slice","variables","runNextStep","session","curState","steps","nextStep","Array","isArray","runStatement","String","Number","autoRun","mapDispatchToProps","handleLoadProgram","_ref2","loadProgram","handleRunNextStep","handleSaveValue","_ref3","Value","connect","state","hasProgramBeenLoaded","variable","react_default","a","createElement","style","marginBottom","color","fontSize","fontWeight","onChange","target","lineHeight","height","split","width","disabled","onClick","identifiers","marginRight","submitInput","inputValue","handleNewValue","handleValue","handleSubmitInput","_ref4","handleToggleAutoRun","App","parsingErrorMsg","parsingError","printedLines","isWaitingForInput","_","map","id","_useState","useState","_useState2","slicedToArray","setIdentifier","_useState3","_useState4","input","setInput","display","margin","transform","padding","marginLeft","border","backgroundColor","fontFamily","minHeight","line","i","initialState","undefined","runtimeError","fib","fibLoop","combineReducers","store","arguments","action","toConsumableArray","defineProperty","Boolean","window","location","hostname","localStorage","getItem","createStore","mainReducer","JSON","parse","applyMiddleware","ReduxThunk","subscribe","setItem","stringify","ReactDOM","render","es","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d81775c3.chunk.js","sourcesContent":["export const IS_COLON_REGEX = /^:$/;\nexport const IS_IDENTIFIER_REGEX = /^[a-z$_]+[a-z0-9$_]*$/i;\nexport const IS_NEWLINE_REGEX = /^\\n$/;\nexport const IS_SEMICOLON_REGEX = /^;$/;\nexport const IS_STRING_LITERAL_REGEX = /^\"[^\"]*\"$/i; //anything inside double quotes, no escaping currently\nexport const IS_STRING_LITERAL_DELIMITER_REGEX = /^\"$/;\nexport const IS_WHITESPACE_REGEX = /^\\s+$/;\n","import {\n  IS_COLON_REGEX,\n  IS_NEWLINE_REGEX,\n  IS_SEMICOLON_REGEX,\n  IS_STRING_LITERAL_DELIMITER_REGEX,\n  IS_WHITESPACE_REGEX\n} from \"./regexes\";\n\nexport class Char {\n  constructor(private char: string) {}\n\n  public isTokenDelimiter(): boolean {\n    return (\n      this.isWhitespace() ||\n      this.isNewline() ||\n      this.isSemicolon() ||\n      this.isColon()\n    );\n  }\n\n  public getValue(): string {\n    return this.char;\n  }\n\n  public isWhitespace(): boolean {\n    return !!this.char.match(IS_WHITESPACE_REGEX);\n  }\n\n  public isSemicolon(): boolean {\n    return !!this.char.match(IS_SEMICOLON_REGEX);\n  }\n\n  private isColon(): boolean {\n    return !!this.char.match(IS_COLON_REGEX);\n  }\n\n  public isNewline(): boolean {\n    return !!this.char.match(IS_NEWLINE_REGEX);\n  }\n\n  public isEndOfStatement(): boolean {\n    return this.isNewline();\n  }\n\n  public isStringDelimiter(): boolean {\n    return !!this.char.match(IS_STRING_LITERAL_DELIMITER_REGEX);\n  }\n}\n","import { IS_IDENTIFIER_REGEX, IS_STRING_LITERAL_REGEX } from \"./regexes\";\n\nexport class Token {\n  constructor(private tokenString: string) {}\n\n  public isKeyword(keyword: string): boolean {\n    return this.tokenString === keyword;\n  }\n\n  public isIdentifier(): boolean {\n    return !!this.tokenString.match(IS_IDENTIFIER_REGEX);\n  }\n\n  public isStringLiteral(): boolean {\n    return !!this.tokenString.match(IS_STRING_LITERAL_REGEX);\n  }\n\n  public getStringValue(): string {\n    return this.tokenString;\n  }\n}\n","import { Char } from \"./char\";\nimport { Token } from \"./token\";\n\nimport {\n  ADD_KEYWORD,\n  IF_EQUAL_KEYWORND,\n  IF_NOT_EQUAL_KEYWORD,\n  INPUT_KEYWORD,\n  PRINT_KEYWORD,\n  RUN_KEYWORD,\n  SET_KEYWORD,\n  STOP_KEYWORD\n} from \"./keywords\";\n\nexport class Parser {\n  private curLoc: number;\n  private isAtEndOfProgram: boolean;\n\n  public constructor(private code: string) {\n    this.curLoc = 0;\n    this.isAtEndOfProgram = false;\n  }\n\n  public generateAST() {\n    return this.parseProgram();\n  }\n\n  private parseProgram() {\n    const startLoc = this.curLoc;\n\n    const statements: any = [];\n\n    let statement: any;\n    while ((statement = this.parseStatement({ nested: false }))) {\n      statements.push(statement);\n    }\n\n    const endLoc = this.curLoc;\n\n    return {\n      type: \"Program\",\n      statements,\n      loc: {\n        start: startLoc,\n        end: endLoc\n      }\n    };\n  }\n\n  private parseStatement({ nested }: any): any {\n    this.skipWhitespace();\n\n    const startLoc = this.curLoc;\n\n    let statement;\n\n    const nextToken = this.peekAtNextToken();\n\n    if (nextToken.isKeyword(ADD_KEYWORD)) {\n      statement = this.parseAddStatement();\n    }\n\n    if (nextToken.isKeyword(IF_EQUAL_KEYWORND)) {\n      statement = this.parseIfEqualStatement();\n    }\n\n    if (nextToken.isKeyword(IF_NOT_EQUAL_KEYWORD)) {\n      statement = this.parseIfNotEqualStatement();\n    }\n\n    if (nextToken.isKeyword(INPUT_KEYWORD)) {\n      statement = this.parseInputStatement();\n    }\n\n    if (nextToken.isKeyword(PRINT_KEYWORD)) {\n      statement = this.parsePrintStatement();\n    }\n\n    if (nextToken.isKeyword(RUN_KEYWORD)) {\n      statement = this.parseRunStatement();\n    }\n\n    if (nextToken.isKeyword(SET_KEYWORD)) {\n      statement = this.parseSetStatement();\n    }\n\n    if (nextToken.isKeyword(STOP_KEYWORD)) {\n      statement = this.parseStopStatement();\n    }\n\n    if (!this.isAtEndOfProgram && this.curChar().isSemicolon()) {\n      statement = this.parseSemicolonStatement(statement);\n    }\n\n    if (!nested) {\n      this.eatEndOfStatement();\n    }\n\n    if (statement) {\n      const endLoc = this.curLoc;\n      return { ...statement, loc: { start: startLoc, end: endLoc } };\n    }\n\n    if (this.isAtEndOfProgram) {\n      return false;\n    }\n\n    throw Error(\"Unknown statement type encountered\");\n  }\n\n  private parseAddStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(ADD_KEYWORD)) {\n      throw Error(\"Expected add keyword\");\n    }\n\n    const first = this.parseExpression();\n    const second = this.parseExpression();\n    const sum = this.parseIdentifier();\n\n    return {\n      type: \"AddStatement\",\n      first,\n      second,\n      sum\n    };\n  }\n\n  private parseIfEqualStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(IF_EQUAL_KEYWORND)) {\n      throw Error(\"Expected ifeq keyword\");\n    }\n\n    const firstAntecedentValue = this.parseExpression();\n    const secondAntecedentValue = this.parseExpression();\n\n    this.skipWhitespace();\n    this.eatChar(\":\");\n    this.skipWhitespace();\n\n    const consequent = this.parseStatement({ nested: true });\n\n    return {\n      type: \"IfEqualStatement\",\n      firstAntecedentValue,\n      secondAntecedentValue,\n      consequent\n    };\n  }\n\n  private parseIfNotEqualStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(IF_NOT_EQUAL_KEYWORD)) {\n      throw Error(\"Expected ifnoteq keyword\");\n    }\n\n    const firstAntecedentValue = this.parseExpression();\n    const secondAntecedentValue = this.parseExpression();\n\n    this.skipWhitespace();\n    this.eatChar(\":\");\n    this.skipWhitespace();\n\n    const consequent = this.parseStatement({ nested: true });\n\n    return {\n      type: \"IfNotEqualStatement\",\n      firstAntecedentValue,\n      secondAntecedentValue,\n      consequent\n    };\n  }\n\n  private parseInputStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(INPUT_KEYWORD)) {\n      throw Error(\"Expected input keyword\");\n    }\n\n    const identifier = this.parseIdentifier();\n\n    return {\n      type: \"InputStatement\",\n      identifier\n    };\n  }\n\n  private parsePrintStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(PRINT_KEYWORD)) {\n      throw Error(\"Expected print keyword\");\n    }\n\n    const expression = this.parseExpression();\n\n    return {\n      type: \"PrintStatement\",\n      expression\n    };\n  }\n\n  private parseRunStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(RUN_KEYWORD)) {\n      throw Error(\"Expected run keyword\");\n    }\n\n    const program = this.parseExpression();\n\n    return {\n      type: \"RunStatement\",\n      program\n    };\n  }\n\n  private parseSemicolonStatement(firstStatement: any) {\n    this.eatChar(\";\");\n    const secondStatement = this.parseStatement({ nested: true });\n\n    return {\n      type: \"SemicolonStatement\",\n      firstStatement,\n      secondStatement\n    };\n  }\n\n  private parseSetStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(SET_KEYWORD)) {\n      throw Error(\"Expected set keyword\");\n    }\n\n    const identifier = this.parseIdentifier();\n\n    const expression = this.parseExpression();\n\n    return {\n      type: \"SetStatement\",\n      identifier,\n      expression\n    };\n  }\n\n  private parseStopStatement() {\n    const nextToken = this.eatToken();\n\n    if (!nextToken.isKeyword(STOP_KEYWORD)) {\n      throw Error(\"Expected run keyword\");\n    }\n\n    return {\n      type: \"StopStatement\"\n    };\n  }\n\n  private eatEndOfStatement() {\n    //end of program works as end of statement\n    if (!this.isThereANextChar()) {\n      this.isAtEndOfProgram = true;\n      return;\n    }\n\n    let wasEndOfStatementEncountered = false;\n\n    while (this.curChar().isEndOfStatement() || this.curChar().isWhitespace()) {\n      if (this.curChar().isEndOfStatement()) {\n        if (this.isThereANextChar()) {\n          this.goToNextChar();\n        } else {\n          this.isAtEndOfProgram = true;\n        }\n\n        wasEndOfStatementEncountered = true;\n        break;\n      }\n\n      // is non-statement-ending whitespace in this case\n      if (this.isThereANextChar()) {\n        this.goToNextChar();\n      } else {\n        this.isAtEndOfProgram = true;\n        break;\n      }\n    }\n\n    if (!wasEndOfStatementEncountered && !this.isAtEndOfProgram) {\n      throw Error(\"Expected end of statement\");\n    }\n  }\n\n  private parseExpression() {\n    this.skipWhitespace();\n\n    const nextToken = this.eatToken();\n\n    if (nextToken.isStringLiteral()) {\n      return {\n        type: \"StringLiteral\",\n        value: nextToken.getStringValue()\n      };\n    }\n\n    if (nextToken.isIdentifier()) {\n      return {\n        type: \"Identifier\",\n        value: nextToken.getStringValue()\n      };\n    }\n\n    throw Error(\"Expression expected\");\n  }\n\n  private parseIdentifier() {\n    this.skipWhitespace();\n\n    const nextToken = this.eatToken();\n\n    if (nextToken.isIdentifier()) {\n      return {\n        type: \"Identifier\",\n        value: nextToken.getStringValue()\n      };\n    }\n\n    throw Error(\"Identifier expected\");\n  }\n\n  private curChar(): Char {\n    return new Char(this.code[this.curLoc]);\n  }\n\n  private peekAtNextChar(): Char {\n    return new Char(this.code[this.curLoc + 1]);\n  }\n\n  private eatChar(expectedChar: string) {\n    if (this.curChar().getValue() !== expectedChar) {\n      throw Error(`Expected ${expectedChar} character`);\n    }\n\n    if (this.isThereANextChar()) {\n      this.goToNextChar();\n    } else {\n      this.isAtEndOfProgram = true;\n    }\n  }\n\n  private eatToken(): Token {\n    this.skipWhitespace();\n    let tokenString = \"\";\n\n    // token delimiter occur in string litrals\n    // so we have two different approaches depending on\n    // whether we're dealing with a string literal vs\n    // something where token delimiters matter\n    if (this.curChar().isStringDelimiter()) {\n      tokenString = this.eatStringLiteral();\n    } else {\n      while (!this.curChar().isTokenDelimiter()) {\n        tokenString += this.curChar().getValue();\n        if (this.isThereANextChar()) {\n          this.goToNextChar();\n        } else {\n          this.isAtEndOfProgram = true;\n          break;\n        }\n      }\n    }\n\n    return new Token(tokenString);\n  }\n\n  private eatStringLiteral(): string {\n    let stringLiteral = \"\";\n\n    if (!this.curChar().isStringDelimiter()) {\n      throw Error(\"Expected string delimiter\");\n    }\n\n    stringLiteral += this.curChar().getValue();\n\n    if (!this.isThereANextChar()) {\n      throw Error(\"Reached end of parsing in middle of string literal parsing\");\n    }\n\n    // don't need guard here because of immediately preceding conditional error\n    this.goToNextChar();\n\n    while (!this.curChar().isStringDelimiter()) {\n      stringLiteral += this.curChar().getValue();\n\n      if (!this.isThereANextChar()) {\n        throw Error(\n          \"Reached end of parsing in middle of string literal parsing\"\n        );\n      }\n\n      // don't need guard here because of immediately preceding conditional error\n      this.goToNextChar();\n    }\n\n    // add final delimiter to value\n    stringLiteral += this.curChar().getValue();\n\n    if (this.isThereANextChar()) {\n      this.goToNextChar();\n    } else {\n      this.isAtEndOfProgram = true;\n    }\n\n    return stringLiteral;\n  }\n\n  private peekAtNextToken(): Token {\n    const loc = this.curLoc;\n    let tokenString = \"\";\n\n    while (!this.curChar().isTokenDelimiter()) {\n      tokenString += this.curChar().getValue();\n      if (this.isThereANextChar()) {\n        this.goToNextChar();\n      } else {\n        this.isAtEndOfProgram = true;\n        break;\n      }\n    }\n\n    // rewind\n    this.curLoc = loc;\n\n    return new Token(tokenString);\n  }\n\n  private skipWhitespace(): void {\n    while (this.curChar().isWhitespace()) {\n      if (this.isThereANextChar()) {\n        this.goToNextChar();\n      } else {\n        this.isAtEndOfProgram = true;\n        break;\n      }\n    }\n  }\n\n  private isThereANextChar(): boolean {\n    return this.curLoc + 1 < this.code.length;\n  }\n\n  private goToNextChar() {\n    this.curLoc++;\n  }\n}\n","export const ADD_KEYWORD = \"add\";\nexport const IF_EQUAL_KEYWORND = \"ifeq\";\nexport const IF_NOT_EQUAL_KEYWORD = \"ifnoteq\";\nexport const INPUT_KEYWORD = \"input\";\nexport const PRINT_KEYWORD = \"print\";\nexport const RUN_KEYWORD = \"run\";\nexport const SET_KEYWORD = \"set\";\nexport const STOP_KEYWORD = \"stop\";\n","import { Parser } from \"../parser\";\n\nexport function loadProgramFromString({ code }: { code: string }) {\n  return function(dispatch: any, getState: any) {\n    const parser = new Parser(code);\n    let program;\n\n    try {\n      program = parser.generateAST();\n    } catch (e) {\n      console.log(\"e\", e);\n      dispatch({\n        type: \"PARSING_ERROR\",\n        errorMsg: e.message\n      });\n      return;\n    }\n\n    const statements = program.statements;\n\n    dispatch({\n      type: \"LOAD_PROGRAM\",\n      statements\n    });\n  };\n}\n","export function saveValue({\n  identifier,\n  value\n}: {\n  identifier: string;\n  value: string;\n}) {\n  return function(dispatch: any, getState: any) {\n    dispatch({\n      type: \"SAVE_VALUE\",\n      identifier,\n      value\n    });\n  };\n}\n","import { loadProgramFromString } from \"./loadProgramFromString\";\nimport { saveValue } from \"./saveValue\";\n\nfunction evaluateExpression(expression: any, getState: any) {\n  return expression.type === \"StringLiteral\"\n    ? expression.value.slice(1, -1)\n    : getState().variables[expression.value];\n}\n\nexport function runStatement({ statement }: any) {\n  return (dispatch: any, getState: any) => {\n    if (statement.type === \"AddStatement\") {\n      const first = evaluateExpression(statement.first, getState);\n      const second = evaluateExpression(statement.second, getState);\n      const identifier = statement.sum.value;\n\n      dispatch(\n        saveValue({\n          identifier,\n          value: String(Number(first) + Number(second))\n        })\n      );\n    } else if (statement.type === \"IfEqualStatement\") {\n      const firstAntecedentValue = evaluateExpression(\n        statement.firstAntecedentValue,\n        getState\n      );\n      const secondAntecedentValue = evaluateExpression(\n        statement.secondAntecedentValue,\n        getState\n      );\n\n      const consequent = statement.consequent;\n      if (firstAntecedentValue === secondAntecedentValue) {\n        dispatch(\n          runStatement({\n            statement: consequent\n          })\n        );\n      }\n    } else if (statement.type === \"IfNotEqualStatement\") {\n      const firstAntecedentValue = evaluateExpression(\n        statement.firstAntecedentValue,\n        getState\n      );\n      const secondAntecedentValue = evaluateExpression(\n        statement.secondAntecedentValue,\n        getState\n      );\n\n      const consequent = statement.consequent;\n      if (firstAntecedentValue !== secondAntecedentValue) {\n        dispatch(\n          runStatement({\n            statement: consequent\n          })\n        );\n      }\n    } else if (statement.type === \"PrintStatement\") {\n      const value = evaluateExpression(statement.expression, getState);\n      dispatch({\n        type: \"PRINT_LINE\",\n        value\n      });\n    } else if (statement.type === \"RunStatement\") {\n      const code = evaluateExpression(statement.program, getState);\n      dispatch(loadProgramFromString({ code }));\n    } else if (statement.type === \"SetStatement\") {\n      const identifier = statement.identifier.value;\n      const value = evaluateExpression(statement.expression, getState);\n      dispatch(\n        saveValue({\n          identifier,\n          value\n        })\n      );\n    } else if (statement.type === \"SemicolonStatement\") {\n      dispatch(\n        runStatement({\n          statement: statement.firstStatement\n        })\n      );\n      dispatch(\n        runStatement({\n          statement: statement.secondStatement\n        })\n      );\n    } else if (statement.type === \"StopStatement\") {\n      dispatch({\n        type: \"STOP\"\n      });\n    }\n  };\n}\n","import { runStatement } from \"./runStatement\";\n\nexport function runNextStep() {\n  return function(dispatch: any, getState: any) {\n    if (getState().session.curState === \"WAITING_FOR_INPUT\") {\n      return;\n    }\n\n    const steps = getState().steps;\n    if (steps.length === 0) {\n      return;\n    }\n\n    let nextStep = steps[0];\n    // accounts for nested programs\n    while (Array.isArray(nextStep)) {\n      nextStep = nextStep[0];\n    }\n\n    if (nextStep.type === \"InputStatement\") {\n      dispatch({\n        type: \"CHANGE_CUR_STATE\",\n        curState: \"WAITING_FOR_INPUT\"\n      });\n\n      return; // return here to avoid completed the action and removing it from step stack\n    }\n\n    // remove first so if things are added to stack, the newly added things don't get removed\n    dispatch({\n      type: \"POP_STEP_OFF_STACK\"\n    });\n\n    dispatch(runStatement({ statement: nextStep }));\n\n    if (getState().session.autoRun) {\n      dispatch(runNextStep());\n    }\n  };\n}\n","import React from \"react\";\nimport { connect } from \"react-redux\";\n\nimport { loadProgram } from \"../actions/loadProgram\";\nimport { runNextStep } from \"../actions/runNextStep\";\nimport { saveValue } from \"../actions/saveValue\";\n\nexport const ValuePresentational: React.FC = ({\n  handleLoadProgram,\n  handleRunNextStep,\n  handleSaveValue,\n  hasProgramBeenLoaded,\n  variable\n}: any) => {\n  return (\n    <div style={{ marginBottom: \"10px\" }}>\n      <div style={{ color: \"#999\", fontSize: \"12px\", fontWeight: 600 }}>\n        {variable.identifier}\n      </div>\n      <textarea\n        onChange={e => {\n          handleSaveValue({\n            identifier: variable.identifier,\n            value: e.target.value\n          });\n        }}\n        style={{\n          fontSize: \"16px\",\n          lineHeight: \"20px\",\n          height: variable.value.split(/\\r\\n|\\r|\\n/).length * 20 + \"px\",\n          width: \"400px\"\n        }}\n        value={variable.value}\n      />\n      <br />\n      <button\n        disabled={hasProgramBeenLoaded}\n        onClick={() => {\n          handleLoadProgram({ identifier: variable.identifier });\n          handleRunNextStep({ identifier: variable.identifiers });\n        }}\n        style={{ marginRight: \"10px\" }}\n      >\n        load and run\n      </button>\n    </div>\n  );\n};\n\nconst mapStateToProps = (state: any) => ({\n  hasProgramBeenLoaded: state.steps.length > 0\n});\n\nconst mapDispatchToProps = {\n  handleLoadProgram: ({ identifier }: any) => loadProgram({ identifier }),\n  handleRunNextStep: () => runNextStep(),\n  handleSaveValue: ({ identifier, value }: any) =>\n    saveValue({ identifier, value })\n};\n\nexport const Value: any = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ValuePresentational);\n","import { loadProgramFromString } from \"./loadProgramFromString\";\n\nexport function loadProgram({ identifier }: { identifier: string }) {\n  return function(dispatch: any, getState: any) {\n    const code = getState().variables[identifier];\n    dispatch(loadProgramFromString({ code }));\n  };\n}\n","import { finishProcessingInput } from \"./finishProcessingInput\";\n\nexport function submitInput({ value }: { value: string }) {\n  return function(dispatch: any, getState: any) {\n    dispatch({\n      type: \"SUBMIT_INPUT\",\n      value\n    });\n\n    dispatch(finishProcessingInput());\n  };\n}\n","import { runNextStep } from \"./runNextStep\";\n\nexport function finishProcessingInput() {\n  return function(dispatch: any, getState: any) {\n    if (getState().session.curState === \"WAITING_FOR_INPUT\") {\n      return;\n    }\n\n    const steps = getState().steps;\n\n    let nextStep = steps[0];\n    // accounts for nested programs\n    while (Array.isArray(nextStep)) {\n      nextStep = nextStep[0];\n    }\n\n    const identifier = nextStep.identifier.value;\n\n    dispatch({\n      type: \"SAVE_VALUE\",\n      identifier,\n      value: getState().session.inputValue\n    });\n\n    dispatch({\n      type: \"POP_STEP_OFF_STACK\"\n    });\n\n    if (getState().session.autoRun) {\n      dispatch(runNextStep());\n    }\n  };\n}\n","import * as _ from \"lodash\";\nimport React, { useState } from \"react\";\nimport { connect } from \"react-redux\";\n\nimport { Value } from \"./Value\";\n\nimport { saveValue } from \"../actions/saveValue\";\nimport { submitInput } from \"../actions/submitInput\";\nimport { toggleAutoRun } from \"../actions/toggleAutoRun\";\n\nconst AppPresentational: React.FC = ({\n  handleNewValue,\n  handleSubmitInput,\n  isWaitingForInput,\n  parsingErrorMsg,\n  printedLines,\n  variables\n}: any) => {\n  const [identifier, setIdentifier] = useState(\"\");\n  const [input, setInput] = useState(\"\");\n\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        margin: \"100px auto\",\n        width: \"1000px\",\n        transform: \"scale(1.2, 1.2)\"\n      }}\n    >\n      <div\n        style={{\n          padding: \"30px\",\n          width: \"440px\"\n        }}\n      >\n        {parsingErrorMsg && (\n          <div style={{ color: \"red\", marginBottom: \"20px \" }}>\n            Parsing error: {parsingErrorMsg}\n          </div>\n        )}\n\n        <input\n          onChange={e => setIdentifier(e.target.value)}\n          type=\"text\"\n          value={identifier}\n        />\n        <button\n          onClick={() => handleNewValue({ identifier })}\n          style={{ marginLeft: \"5px\" }}\n        >\n          Create new variable\n        </button>\n        <div style={{ height: \"20px\" }} />\n        {isWaitingForInput && (\n          <div>\n            Input\n            <div>\n              <input\n                style={{ border: \"1px solid red\", marginRight: \"10px\" }}\n                onChange={e => setInput(e.target.value)}\n                type=\"text\"\n                value={input}\n              />\n              <button onClick={() => handleSubmitInput({ value: input })}>\n                Submit user input\n              </button>\n            </div>\n          </div>\n        )}\n        <div style={{ height: \"20px\" }} />\n        <div>\n          Output\n          <div\n            style={{\n              backgroundColor: \"#eee\",\n              border: \"1px solid gray\",\n              color: \"#111\",\n              fontFamily: \"monospace\",\n              minHeight: \"50px\"\n            }}\n          >\n            {printedLines.map((line: any, i: number) => (\n              <div key={i}>{line}</div>\n            ))}\n          </div>\n        </div>\n      </div>\n\n      <div\n        style={{\n          width: \"500px\"\n        }}\n      >\n        {variables.map((variable: any) => (\n          <Value variable={variable} key={variable.identifier} />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nconst mapStateToProps = (state: any) => ({\n  parsingErrorMsg: state.session.parsingError,\n  printedLines: state.printedLines,\n  isWaitingForInput: state.session.curState === \"WAITING_FOR_INPUT\",\n  variables: _.keys(state.variables).map(id => ({\n    identifier: id,\n    value: state.variables[id]\n  }))\n});\n\nconst mapDispatchToProps = {\n  handleNewValue: ({ identifier }: any) => saveValue({ identifier, value: \"\" }),\n  handleValue: ({ identifier }: any) => saveValue({ identifier, value: \"\" }),\n  handleSubmitInput: ({ value }: any) => submitInput({ value }),\n  handleToggleAutoRun: toggleAutoRun\n};\n\nexport const App: any = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(AppPresentational);\n","export function toggleAutoRun() {\n  return function(dispatch: any, getState: any) {\n    dispatch({\n      type: \"TOGGLE_AUTO_RUN\"\n    });\n  };\n}\n","const initialState: any = [];\n\nexport default function printedLines(state = initialState, action: any) {\n  if (action.type === \"PRINT_LINE\") {\n    return [...state, action.value];\n  }\n\n  return state;\n}\n","const initialState = {\n  autoRun: true,\n  curState: \"IDLE\",\n  inputValue: undefined,\n  parsingError: undefined,\n  runtimeError: undefined\n};\n\nexport default function(state = initialState, action: any) {\n  if (action.type === \"CHANGE_CUR_STATE\") {\n    return {\n      ...state,\n      curState: action.curState\n    };\n  }\n\n  if (action.type === \"SUBMIT_INPUT\") {\n    return {\n      ...state,\n      curState: \"IDLE\",\n      inputValue: action.value\n    };\n  }\n\n  if (action.type === \"TOGGLE_AUTO_RUN\") {\n    return {\n      ...state,\n      autoRun: !state.autoRun\n    };\n  }\n\n  if (action.type === \"PARSING_ERROR\") {\n    console.log(\"here\");\n    return {\n      ...state,\n      parsingError: action.errorMsg\n    };\n  }\n\n  return state;\n}\n","const initialState: any = [];\n\nexport default function variablesReducer(state = initialState, action: any) {\n  if (action.type === \"LOAD_PROGRAM\") {\n    return [[...action.statements], ...state];\n  }\n\n  if (action.type === \"POP_STEP_OFF_STACK\") {\n    if (state[0].length === 1) {\n      console.log(state, \"++====>\", state.slice(1));\n      return state.slice(1);\n    } else {\n      console.log(state, \"====>\", [[...state[0].slice(1)], ...state.slice(1)]);\n      return [[...state[0].slice(1)], ...state.slice(1)];\n    }\n  }\n\n  if (action.type === \"STOP\") {\n    return state.slice(1);\n  }\n\n  return state;\n}\n","const initialState = {\n  fib: `print \"Which Fibonacci number do you want to calculate?\"\ninput n\nset a \"0\"\nset b \"1\"\nifeq n \"0\": print a; stop\nset i \"2\"\nrun fibLoop`,\n  fibLoop: `add a b c\nset a b\nset b c\nifeq i n: print b; stop\nifnoteq i n: add i \"1\" i; run fibLoop`\n};\n\nexport default function variablesReducer(state = initialState, action: any) {\n  if (action.type === \"SAVE_VALUE\") {\n    return {\n      ...state,\n      [action.identifier]: action.value\n    };\n  }\n\n  return state;\n}\n","import { combineReducers } from \"redux\";\n\nimport printedLines from \"./printedLines\";\nimport session from \"./session\";\nimport steps from \"./steps\";\nimport variables from \"./variables\";\n\nexport default combineReducers({\n  printedLines,\n  session,\n  steps,\n  variables\n});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { applyMiddleware, createStore } from \"redux\";\nimport ReduxThunk from \"redux-thunk\";\n\nimport { App } from \"./components/App\";\nimport mainReducer from \"./reducers\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nlet store: any;\nif (localStorage.getItem(\"ought-ide\") !== null) {\n  store = createStore(\n    mainReducer,\n    JSON.parse(localStorage.getItem(\"ought-ide\") as string),\n    applyMiddleware(ReduxThunk)\n  );\n} else {\n  store = createStore(mainReducer, applyMiddleware(ReduxThunk));\n}\n\nstore.subscribe(() =>\n  localStorage.setItem(\"ought-ide\", JSON.stringify(store.getState()))\n);\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n"],"sourceRoot":""}